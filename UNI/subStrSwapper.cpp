/*

This command line program reads the specified file, iterate through every line in it and
replace each occurrence of the substrings an other specified substrings.

Two type of usage has been implemented:

    1. You specify the strings in the command line:

            ./subStrSwapper input_file.txt output_file.txt old_substr1 new_substr1 old_substr2 new_substr2 ....  //it can take any number of args, if they are in pairs
            
    2.You read the pairs from a text file, where the strings are separated with a space and every single pair takes place in a new line. (old_substr1 new_substr1)
                                                                                                                                          (old_substr2 new_substr2)
            ./subStrSwaooer input_file.txt output_file.txt -pair pairs.txt (-spc \${IFS})                                                            ...
                                                            |                |                 
                                                    flag to specify     optional flag to
                                                    the pairs-file.     replace spaces 
*/

#include<iostream>
#include<fstream>
#include<cstdlib>
#include<vector>

using namespace std;

//Function to swap all occurrences of a substring with a replacement string
void swapSubstr(string& str, const string& substr, const string& replacement) {

    size_t pos = 0;
    size_t substrLen = substr.length();
    size_t replacementLen = replacement.length();

    while ((pos = str.find(substr, pos)) != string::npos) {
        str.replace(pos, substrLen, replacement); 
            pos += replacementLen; 
    }
}

int main(int argc, char *argv[]){
            
            const char* pair_flag="-pair"; //Option flag for using a pair-file
            const char* space_flag ="-spc"; //Option flag for swap spaces

            #pragma region<arguments_error_handling>

                    if(argc<5){
                        cerr << "The number of arguments is to few." << endl;
                            cout << "Usage: scheme: ./executable inputfile outputfile oldstr1 newstr2 oldstr2 newstr2 ... ";
                                return 1;
                    } 
                    else if((argc%2==0) && (argc>5) && (strcmp(argv[3],pair_flag))){
                        cerr << "The number of arguments doesnt match the prerequisites. The strings to be swapped should be pairs." << endl;
                            cout << "Usage: scheme: ./executable inputfile outputfile oldstr1 newstr2 oldstr2 newstr2 ... ";
                                return 1;
                    }

            cout << endl << "The followings will be swapped:" << endl;

            #pragma endregion<arguments_error_handling>

                    bool usePairFile = false;
                    string pairFileName;
                    vector<string> old_str;
                    vector<string> new_str;
                    bool spaceSwap = false;
                    string forSpaces;

                    //Check optional flags
                    if(!strcmp(argv[3], pair_flag)){usePairFile=true; pairFileName=argv[4];}
                    if(!strcmp(argv[5], space_flag)){forSpaces=argv[6]; spaceSwap=true; cout << "\t\t\t\tSpaces " << "with " << argv[6] << endl;}

                    if(usePairFile){  //If using a pairs file, read the pairs from the file  
                        
                        ifstream pairs(pairFileName);
                        string old_string, new_string, pair_line;

                        if (!pairs.is_open()) {
                            cerr << "Unable to open the pairs file: " << endl;
                                return 1;
                        }

                        while(getline(pairs, pair_line)){ 
                            int separator = pair_line.find(" ");
                                old_string = pair_line.substr(0, separator);
                                    new_string = pair_line.substr(separator+1);
                                        old_str.push_back(old_string);
                                            new_str.push_back(new_string);
                        }
                        pairs.close();
                        
                    }else{     //If not using a pairs file, read pairs from the command line arguments
                        for(int i=3; i<argc; i++){
                            (i%2!=0)?old_str.push_back(argv[i]):new_str.push_back(argv[i]);
                        }
                    }

                    string inputfileName = argv[1];
                    string outputfileName = argv[2]; 
                    string in_line;

                    ifstream input(inputfileName);
                    ofstream output(outputfileName, ios::app);

                #pragma region<file_error_handling>

                    if (!input.is_open()){
                            cerr << "Unable to open the file!" << endl;
                                return 1;
                    }

                    if (!output.is_open()){
                            cerr << "The output file cannot be saved." <<endl;
                                return 1;
                    }

                #pragma endregion<file_error_handling>

                    //Print the pairs that will be swapped (intendation: backcecking)
                    for (int j=0; j<(new_str.size()); j++){
                        cout << "\t\t\t\t" << old_str[j] << " with " << new_str[j] << endl;
                    }
                    cout << endl; 
                    
                    while(getline(input, in_line)){

                        string out_line = in_line;

                            for (int i=0; i<new_str.size(); i++){                            
                                swapSubstr(out_line, old_str[i], new_str[i]);
                                if(spaceSwap){swapSubstr(out_line, " ", forSpaces);}
                            }
                                output << out_line << endl;
                        }

                    input.close();output.close();

    return 0;
}
